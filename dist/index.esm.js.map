{"version":3,"file":"index.esm.js","sources":["../src/types/index.ts","../src/core/SVGParser.ts","../src/utils/fileUtils.ts","../src/core/KanjiVG.ts"],"sourcesContent":["// Core data interfaces for KanjiVG library\n\nexport interface KanjiData {\n  // Core identifiers\n  character: string;           // The kanji character (e.g., \"車\")\n  unicode: string;             // Unicode codepoint (e.g., \"08eca\")\n  variant?: string;            // Variant identifier if present (e.g., \"Kaisho\")\n  isVariant: boolean;          // True if this is a variant form\n  \n  // Structure\n  strokes: StrokeData[];        // All strokes in order\n  groups: GroupData[];         // Group hierarchy for radical identification\n  radicalInfo?: RadicalInfo;   // Radical information if available\n  \n  // Metadata\n  strokeCount: number;         // Total number of strokes\n  components?: string[];       // Component decomposition\n}\n\nexport interface StrokeData {\n  strokeNumber: number;        // 1-based stroke order\n  path: string;               // SVG path data (d attribute)\n  strokeType: string;         // kvg:type (e.g., \"㇐\", \"㇑\")\n  numberPosition?: {          // Position for stroke number annotation\n    x: number;\n    y: number;\n  };\n  groupId?: string;          // Which group this stroke belongs to\n  isRadicalStroke?: boolean;  // True if part of a radical group\n}\n\nexport interface GroupData {\n  id: string;                 // Group identifier\n  element?: string;           // Component kanji (e.g., \"木\")\n  radical?: string;           // Radical type (e.g., \"general\")\n  position?: string;          // Spatial position (e.g., \"left\", \"right\")\n  childStrokes: number[];     // Array of stroke numbers in this group\n  children: GroupData[];      // Sub-groups\n}\n\nexport interface RadicalInfo {\n  radical: string;            // The radical character\n  positions: string[];        // Where the radical appears (e.g., [\"left\"])\n  strokeRanges: number[][];   // Which strokes are part of the radical\n}\n\n// Animation and styling interfaces\nexport interface AnimationOptions {\n  strokeDuration: number;      // Duration of each stroke animation (ms)\n  strokeDelay: number;        // Delay between strokes (ms)\n  showNumbers: boolean;        // Show stroke order numbers\n  loop: boolean;              // Loop the animation\n  showTrace: boolean;         // Show outline trace\n  strokeStyling: StrokeStyling;\n  radicalStyling?: RadicalStyling;\n  traceStyling?: TraceStyling;\n  numberStyling?: NumberStyling;\n}\n\nexport interface StrokeStyling {\n  strokeColour: string | string[];  // Single colour or array for cycling\n  strokeThickness: number;\n  strokeRadius: number;\n}\n\nexport interface RadicalStyling {\n  radicalColour: string | string[];  // Overrides stroke styling for radicals\n  radicalThickness: number;\n  radicalRadius: number;\n}\n\nexport interface TraceStyling {\n  traceColour: string;\n  traceThickness: number;\n  traceRadius: number;\n}\n\nexport interface NumberStyling {\n  fontColour: string;\n  fontWeight: number;\n  fontSize: number;\n}\n\n// React component props\nexport interface KanjiCardProps {\n  kanji: string | KanjiData;        // Character or KanjiData object\n  showInfo?: boolean;               // Show info panel\n  animationOptions?: Partial<AnimationOptions>;\n  onAnimationComplete?: () => void;\n  className?: string;\n}\n\n// Error handling\nexport class KanjiVGError extends Error {\n  constructor(message: string, public code: string) {\n    super(message);\n    this.name = 'KanjiVGError';\n  }\n}\n\n// Error codes\nexport const ERROR_CODES = {\n  KANJI_NOT_FOUND: 'KANJI_NOT_FOUND',\n  INVALID_UNICODE: 'INVALID_UNICODE',\n  SVG_PARSE_ERROR: 'SVG_PARSE_ERROR',\n  FILE_LOAD_ERROR: 'FILE_LOAD_ERROR',\n} as const;\n","import { KanjiData, StrokeData, GroupData, RadicalInfo } from '../types';\n\n/**\n * SVG Parser for extracting stroke data from KanjiVG SVG files\n */\nexport class SVGParser {\n  private cache: Map<string, KanjiData> = new Map();\n\n  /**\n   * Parse SVG content and extract all kanji data\n   * @param svgContent - The SVG file content as string\n   * @param unicode - The unicode codepoint (e.g., \"04e00\")\n   * @returns Parsed KanjiData object\n   */\n  parseSVG(svgContent: string, unicode: string): KanjiData {\n    // Check cache first\n    const cacheKey = unicode;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(svgContent, 'image/svg+xml');\n\n    // Extract character\n    const character = this.extractCharacter(doc, unicode);\n    \n    // Extract all strokes in order\n    const strokes = this.extractStrokes(doc);\n    \n    // Extract group hierarchy\n    const groups = this.extractGroups(doc);\n    \n    // Extract radical information\n    const radicalInfo = this.extractRadicalInfo(groups, strokes);\n    \n    // Mark strokes as radical strokes\n    strokes.forEach(stroke => {\n      stroke.isRadicalStroke = this.isRadicalStroke(stroke, groups);\n      stroke.groupId = this.getStrokeGroupId(stroke.strokeNumber, groups);\n    });\n    \n    // Extract stroke number positions\n    const numberPositions = this.extractNumberPositions(doc, strokes.length);\n    strokes.forEach((stroke, index) => {\n      if (numberPositions[index]) {\n        stroke.numberPosition = numberPositions[index];\n      }\n    });\n\n    // Extract components from groups\n    const components = this.extractComponents(groups);\n\n    const kanjiData: KanjiData = {\n      character,\n      unicode,\n      isVariant: false,\n      strokes,\n      groups,\n      radicalInfo,\n      strokeCount: strokes.length,\n      components: components.length > 0 ? components : undefined,\n    };\n\n    // Cache result\n    this.cache.set(cacheKey, kanjiData);\n\n    return kanjiData;\n  }\n\n  /**\n   * Extract the kanji character from the SVG\n   */\n  private extractCharacter(doc: Document, unicode: string): string {\n    const mainGroup = doc.querySelector(`g[id^=\"kvg:${unicode}\"]`);\n    if (mainGroup) {\n      const element = mainGroup.getAttribute('kvg:element');\n      if (element) {\n        return element;\n      }\n    }\n    \n    // Fallback: convert unicode to character\n    return String.fromCodePoint(parseInt(unicode, 16));\n  }\n\n  /**\n   * Extract all stroke path elements in order\n   */\n  private extractStrokes(doc: Document): StrokeData[] {\n    const strokeGroup = doc.querySelector('g[id^=\"kvg:StrokePaths\"]');\n    if (!strokeGroup) {\n      throw new Error('Cannot find StrokePaths group');\n    }\n\n    const paths = Array.from(strokeGroup.querySelectorAll('path')).filter(path => {\n      const id = path.getAttribute('id');\n      return id && id.includes('-s');\n    });\n\n    const strokes: StrokeData[] = [];\n    \n    paths.forEach((path, index) => {\n      const id = path.getAttribute('id') || '';\n      const pathData = path.getAttribute('d') || '';\n      const strokeType = path.getAttribute('kvg:type') || '';\n\n      strokes.push({\n        strokeNumber: index + 1,\n        path: pathData,\n        strokeType,\n      });\n    });\n\n    return strokes;\n  }\n\n  /**\n   * Extract group hierarchy\n   */\n  private extractGroups(doc: Document): GroupData[] {\n    const strokeGroup = doc.querySelector('g[id^=\"kvg:StrokePaths\"]');\n    if (!strokeGroup) {\n      return [];\n    }\n\n    const groups: GroupData[] = [];\n    const groupElements = Array.from(strokeGroup.querySelectorAll('g'));\n\n    groupElements.forEach(groupEl => {\n      const id = groupEl.getAttribute('id');\n      if (!id || !id.includes('-g')) {\n        return;\n      }\n\n      const element = groupEl.getAttribute('kvg:element') || undefined;\n      const radical = groupEl.getAttribute('kvg:radical') || undefined;\n      const position = groupEl.getAttribute('kvg:position') || undefined;\n      \n      // Find child paths to determine stroke numbers\n      const childPaths = Array.from(groupEl.querySelectorAll('path'));\n      const childStrokes: number[] = [];\n      \n      // This is a simplified version - would need to track actual stroke numbers\n      // For now, we'll determine this based on path order in the document\n      const allPaths = Array.from(strokeGroup.querySelectorAll('path'));\n      childPaths.forEach(childPath => {\n        const pathIndex = allPaths.indexOf(childPath);\n        if (pathIndex !== -1) {\n          childStrokes.push(pathIndex + 1);\n        }\n      });\n\n      groups.push({\n        id,\n        element,\n        radical,\n        position,\n        childStrokes,\n        children: [],\n      });\n    });\n\n    return groups;\n  }\n\n  /**\n   * Determine radical information from groups\n   */\n  private extractRadicalInfo(groups: GroupData[], strokes: StrokeData[]): RadicalInfo | undefined {\n    const radicals = groups.filter(g => g.radical);\n    \n    if (radicals.length === 0) {\n      return undefined;\n    }\n\n    // For simplicity, take the first radical found\n    const mainRadical = radicals[0];\n    \n    return {\n      radical: mainRadical.element || mainRadical.radical || 'unknown',\n      positions: mainRadical.position ? [mainRadical.position] : [],\n      strokeRanges: [mainRadical.childStrokes],\n    };\n  }\n\n  /**\n   * Extract stroke number positions from StrokeNumbers section\n   */\n  private extractNumberPositions(doc: Document, strokeCount: number): Array<{ x: number; y: number } | undefined> {\n    const numberGroup = doc.querySelector('g[id^=\"kvg:StrokeNumbers\"]');\n    if (!numberGroup) {\n      return new Array(strokeCount).fill(undefined);\n    }\n\n    const textElements = Array.from(numberGroup.querySelectorAll('text'));\n    const positions: Array<{ x: number; y: number } | undefined> = new Array(strokeCount).fill(undefined);\n\n    textElements.forEach(textEl => {\n      const transform = textEl.getAttribute('transform');\n      const textContent = textEl.textContent?.trim();\n      \n      if (!transform || !textContent) return;\n\n      // Parse transform matrix: matrix(1 0 0 1 x y)\n      const matrixMatch = transform.match(/matrix\\([^)]*\\)/);\n      if (matrixMatch) {\n        const values = matrixMatch[0].match(/[\\d.-]+/g) || [];\n        if (values.length >= 6) {\n          const x = parseFloat(values[4]);\n          const y = parseFloat(values[5]);\n          const strokeNum = parseInt(textContent, 10);\n          \n          if (strokeNum > 0 && strokeNum <= strokeCount) {\n            positions[strokeNum - 1] = { x, y };\n          }\n        }\n      }\n    });\n\n    return positions;\n  }\n\n  /**\n   * Extract component list from groups\n   */\n  private extractComponents(groups: GroupData[]): string[] {\n    const components = new Set<string>();\n    \n    groups.forEach(group => {\n      if (group.element) {\n        components.add(group.element);\n      }\n    });\n\n    return Array.from(components);\n  }\n\n  /**\n   * Check if a stroke belongs to a radical group\n   */\n  private isRadicalStroke(stroke: StrokeData, groups: GroupData[]): boolean {\n    return groups.some(group => \n      group.radical && \n      group.childStrokes.includes(stroke.strokeNumber)\n    );\n  }\n\n  /**\n   * Get the group ID for a stroke\n   */\n  private getStrokeGroupId(strokeNumber: number, groups: GroupData[]): string | undefined {\n    const group = groups.find(g => g.childStrokes.includes(strokeNumber));\n    return group?.id;\n  }\n\n  /**\n   * Clear the cache\n   */\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n","// Utility functions for file handling and data processing\n\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n/**\n * Convert a character or unicode string to canonical unicode format\n */\nexport function toUnicode(input: string): string {\n  if (input.length === 1) {\n    // Single character - convert to unicode\n    const code = input.codePointAt(0);\n    if (!code) {\n      throw new Error(`Invalid character: ${input}`);\n    }\n    return code.toString(16).padStart(5, '0');\n  } else if (input.length >= 2 && input.length <= 5) {\n    // Already unicode format\n    return input.toLowerCase().padStart(5, '0');\n  } else {\n    throw new Error(`Invalid input format: ${input}`);\n  }\n}\n\n/**\n * Convert unicode string to character\n */\nexport function unicodeToChar(unicode: string): string {\n  const code = parseInt(unicode, 16);\n  return String.fromCodePoint(code);\n}\n\n/**\n * Check if a file path represents a variant (has dash in filename)\n */\nexport function isVariantFile(filename: string): boolean {\n  const baseName = path.basename(filename, '.svg');\n  return baseName.includes('-');\n}\n\n/**\n * Extract variant name from filename\n */\nexport function extractVariantName(filename: string): string | undefined {\n  const baseName = path.basename(filename, '.svg');\n  const parts = baseName.split('-');\n  return parts.length > 1 ? parts[1] : undefined;\n}\n\n/**\n * Sort files to put base files before variants\n */\nexport function sortFiles(files: string[]): string[] {\n  return files.sort((a, b) => {\n    const aIsVariant = isVariantFile(a);\n    const bIsVariant = isVariantFile(b);\n    \n    if (aIsVariant && !bIsVariant) return 1;\n    if (!aIsVariant && bIsVariant) return -1;\n    return a.localeCompare(b);\n  });\n}\n\n/**\n * Load JSON file synchronously (for Node.js environments)\n */\nexport function loadJSONFile(filePath: string): any {\n  try {\n    const content = fs.readFileSync(filePath, 'utf8');\n    return JSON.parse(content);\n  } catch (error) {\n    throw new Error(`Failed to load JSON file ${filePath}: ${error}`);\n  }\n}\n\n/**\n * Load text file synchronously (for Node.js environments)\n */\nexport function loadTextFile(filePath: string): string {\n  try {\n    return fs.readFileSync(filePath, 'utf8');\n  } catch (error) {\n    throw new Error(`Failed to load text file ${filePath}: ${error}`);\n  }\n}\n","import { SVGParser } from './SVGParser';\nimport { KanjiData, KanjiVGError, ERROR_CODES } from '../types';\nimport { toUnicode, unicodeToChar } from '../utils/fileUtils';\n\n/**\n * Main KanjiVG class for loading and searching kanji data\n */\nexport class KanjiVG {\n  private parser: SVGParser;\n  private index: Map<string, string[]>; // character -> file list\n  private radicalIndex: Map<string, string[]>; // radical -> character list\n  private indexLoaded: boolean = false;\n  private radicalIndexLoaded: boolean = false;\n\n  constructor() {\n    this.parser = new SVGParser();\n    this.index = new Map();\n    this.radicalIndex = new Map();\n  }\n\n  /**\n   * Initialize by loading the index file\n   * This should be called before using any methods that require index lookups\n   */\n  private async initialize(): Promise<void> {\n    if (this.indexLoaded) {\n      return;\n    }\n\n    try {\n      let indexContent: string;\n\n      // Check if we're in browser environment\n      if (typeof window !== 'undefined' && typeof fetch !== 'undefined') {\n        const response = await fetch('/kvg-index.json');\n        if (!response.ok) {\n          throw new Error(`Failed to fetch index: ${response.status}`);\n        }\n        indexContent = await response.text();\n      } else {\n        // Node.js environment\n        const fs = await import('fs');\n        const path = await import('path');\n        const filePath = path.resolve(__dirname, '../../kvg-index.json');\n        indexContent = fs.readFileSync(filePath, 'utf8');\n      }\n\n      // Parse the JSON index\n      const indexData = JSON.parse(indexContent);\n      \n      // Convert to Map structure\n      this.index = new Map(Object.entries(indexData));\n      this.indexLoaded = true;\n    } catch (error) {\n      throw new KanjiVGError(\n        'Failed to load kanji index',\n        ERROR_CODES.FILE_LOAD_ERROR\n      );\n    }\n  }\n\n  /**\n   * Set the index data (for testing or custom index)\n   */\n  setIndex(index: Map<string, string[]>): void {\n    this.index = index;\n    this.indexLoaded = true;\n  }\n\n  /**\n   * Get kanji data including all variants\n   * @param kanji - Character (e.g., \"車\") or unicode (e.g., \"04e0b\")\n   * @returns Array of KanjiData objects (at least one, more if variants exist)\n   */\n  async getKanji(kanji: string): Promise<KanjiData[]> {\n    // Convert input to unicode\n    let unicode: string;\n    try {\n      unicode = toUnicode(kanji);\n    } catch (error) {\n      throw new KanjiVGError(\n        `Invalid input format: ${kanji}`,\n        ERROR_CODES.INVALID_UNICODE\n      );\n    }\n\n    // Load SVG file content\n    const svgContent = await this.loadSVGFile(unicode);\n    \n    if (!svgContent || svgContent.trim().length === 0) {\n      throw new KanjiVGError(\n        `Kanji '${kanji}' (unicode: ${unicode}) not found in KanjiVG database. This character may not be included in the dataset.`,\n        ERROR_CODES.KANJI_NOT_FOUND\n      );\n    }\n\n    // Debug: log SVG content to help troubleshoot\n    if (!svgContent.includes('<g id=\"kvg:StrokePaths')) {\n      console.error(`SVG file for ${unicode} does not contain expected structure. Content length: ${svgContent.length}`);\n      console.error(`First 200 chars:`, svgContent.substring(0, 200));\n    }\n\n    try {\n      // Parse the SVG\n      const kanjiData = this.parser.parseSVG(svgContent, unicode);\n\n      return [kanjiData];\n    } catch (error) {\n      throw new KanjiVGError(\n        `Failed to parse SVG for ${kanji}: ${error}`,\n        ERROR_CODES.SVG_PARSE_ERROR\n      );\n    }\n  }\n\n  /**\n   * Search for kanji containing a specific radical\n   * @param radical - The radical character (e.g., \"女\")\n   * @returns Array of KanjiData objects\n   */\n  async searchRadical(radical: string): Promise<KanjiData[]> {\n    // Load radical index if not already loaded\n    if (!this.radicalIndexLoaded) {\n      await this.loadRadicalIndex();\n    }\n\n    // Get characters that contain this radical\n    const characters = this.radicalIndex.get(radical) || [];\n    \n    if (characters.length === 0) {\n      return [];\n    }\n\n    // Load kanji data for each character\n    const results: KanjiData[] = [];\n    for (const character of characters) {\n      try {\n        const kanjiData = await this.getKanji(character);\n        results.push(...kanjiData);\n      } catch (error) {\n        // Skip characters that fail to load\n        console.warn(`Failed to load kanji for radical search: ${character}`, error);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Load the radical index file\n   */\n  private async loadRadicalIndex(): Promise<void> {\n    if (this.radicalIndexLoaded) {\n      return;\n    }\n\n    try {\n      let indexContent: string;\n\n      // Check if we're in browser environment\n      if (typeof window !== 'undefined' && typeof fetch !== 'undefined') {\n        const response = await fetch('/radical-index.json');\n        if (!response.ok) {\n          throw new Error(`Failed to fetch radical index: ${response.status}`);\n        }\n        indexContent = await response.text();\n      } else {\n        // Node.js environment\n        const fs = await import('fs');\n        const path = await import('path');\n        const filePath = path.resolve(__dirname, '../../radical-index.json');\n        indexContent = fs.readFileSync(filePath, 'utf8');\n      }\n\n      // Parse the JSON index\n      const indexData = JSON.parse(indexContent);\n      \n      // Convert to Map structure\n      this.radicalIndex = new Map(Object.entries(indexData));\n      this.radicalIndexLoaded = true;\n    } catch (error) {\n      throw new KanjiVGError(\n        'Failed to load radical index',\n        ERROR_CODES.FILE_LOAD_ERROR\n      );\n    }\n  }\n\n  /**\n   * Get a random kanji\n   * @returns Single KanjiData object\n   */\n  async getRandom(): Promise<KanjiData> {\n    if (!this.indexLoaded) {\n      await this.initialize();\n    }\n\n    const chars = Array.from(this.index.keys());\n    if (chars.length === 0) {\n      throw new KanjiVGError(\n        'No kanji available',\n        ERROR_CODES.KANJI_NOT_FOUND\n      );\n    }\n\n    const randomChar = chars[Math.floor(Math.random() * chars.length)];\n    const results = await this.getKanji(randomChar);\n    return results[0]; // Return base (non-variant)\n  }\n\n  /**\n   * Load SVG file content for a given unicode\n   * In browser: loads via import.meta.glob or direct fetch\n   * In Node.js: reads from file system\n   */\n  private async loadSVGFile(unicode: string): Promise<string> {\n    // Check if we're in a browser environment\n    if (typeof window !== 'undefined') {\n      // In development with Vite, the library is loaded via source from src/core\n      // We need to fetch from the kanjivg_js source files\n      try {\n        // For Vite, fetch from the source directory using absolute import\n        const baseUrl = '/src/core/'; // Since we're in core/, go up to access kanji\n        // Vite will handle resolving this from the correct location\n        const response = await fetch(`/kanji/${unicode}.svg`);\n        if (!response.ok && response.status !== 404) {\n          throw new Error(`Failed to fetch SVG: ${response.status}`);\n        }\n        if (response.ok) {\n          return await response.text();\n        }\n        // If 404, try with parent path\n        throw new Error('SVG not found at /kanji/');\n      } catch (error) {\n        // Fallback: in a proper npm package setup, files would be at node_modules/kvg-js/kanji/\n        throw new KanjiVGError(\n          `Failed to load SVG file: ${unicode}.svg. This character may not be in the dataset or files are not accessible. Error: ${error}`,\n          ERROR_CODES.FILE_LOAD_ERROR\n        );\n      }\n    } else {\n      // Node.js environment: use file system\n      const fs = await import('fs');\n      const path = await import('path');\n      \n      try {\n        const filePath = path.resolve(__dirname, `../../kanji/${unicode}.svg`);\n        return fs.readFileSync(filePath, 'utf8');\n      } catch (error) {\n        throw new KanjiVGError(\n          `Failed to load SVG file: ${unicode}.svg`,\n          ERROR_CODES.FILE_LOAD_ERROR\n        );\n      }\n    }\n  }\n\n  /**\n   * Check if kanji data contains a specific radical\n   */\n  private hasRadical(kanjiData: KanjiData[], radical: string): boolean {\n    return kanjiData.some(data => \n      data.radicalInfo?.radical === radical ||\n      data.groups.some(g => g.element === radical || g.radical === radical)\n    );\n  }\n\n  /**\n   * Convert unicode to character\n   */\n  private unicodeToChar(unicode: string): string {\n    return unicodeToChar(unicode);\n  }\n}\n"],"names":[],"mappings":"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"}